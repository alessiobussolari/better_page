# frozen_string_literal: true

# Base class for all form pages (new/edit) in this application.
#
# FORM ORGANIZATION RULES (MANDATORY):
# =====================================
#
# RULE 1: INPUT TYPE SEPARATION
# - CHECKBOX fields must be grouped in dedicated panels
# - RADIO BUTTON fields must be grouped in dedicated panels
# - Text, email, select, textarea, number, date can be mixed together
#
# Components available (from global configuration):
#   Required: header, panels
#   Optional: alerts, errors, footer
#
# Customize this class to:
#   - Add custom components with register_component
#   - Override helper methods
#   - Change stream_components
#
class FormBasePage < ApplicationPage
  page_type :form

  # ─────────────────────────────────────────────────────────────────
  # CUSTOM COMPONENTS
  # ─────────────────────────────────────────────────────────────────
  # Add custom components for all form pages here:
  #
  # register_component :sidebar_help, default: nil
  # register_component :preview, default: { enabled: false }

  # Main method that builds the complete form page configuration
  # @return [Hash] complete form page configuration with :klass for rendering
  def form
    result = build_page
    validate_form_panels_rules(result[:panels]) if result[:panels]
    result
  end

  # The ViewComponent class used to render this form page
  # @return [Class] BetterPage::FormViewComponent
  def view_component_class
    return BetterPage::FormViewComponent if defined?(BetterPage::FormViewComponent)

    raise NotImplementedError, "BetterPage::FormViewComponent not found. Run: rails g better_page:install"
  end

  # Components to include in stream updates by default
  # Override to customize which components update via Turbo Streams
  # @return [Array<Symbol>]
  def stream_components
    %i[alerts errors panels]
  end

  protected

  # Validates that all panels follow the input separation rules
  # Logs warnings in development mode when rules are violated
  # @param panels [Array<Hash>] panels to validate
  # @return [void]
  def validate_form_panels_rules(panels)
    return unless defined?(Rails) && Rails.env.development?

    panels.each_with_index do |panel, index|
      next unless panel[:fields].is_a?(Array)

      checkbox_count = panel[:fields].count { |field| field[:type] == :checkbox }
      radio_count = panel[:fields].count { |field| field[:type] == :radio }
      other_count = panel[:fields].count { |field| %i[checkbox radio].exclude?(field[:type]) }

      if checkbox_count.positive? && other_count.positive?
        Rails.logger.warn "[FormBasePage] RULE VIOLATION in panel '#{panel[:title]}' (#{index}): " \
                          "checkboxes mixed with other inputs"
      end

      if radio_count.positive? && other_count.positive?
        Rails.logger.warn "[FormBasePage] RULE VIOLATION in panel '#{panel[:title]}' (#{index}): " \
                          "radio buttons mixed with other inputs"
      end
    end
  end

  # Helper to build a form field
  # @param name [Symbol] field name
  # @param type [Symbol] field type (:text, :email, :select, :checkbox, etc.)
  # @param label [String] field label
  # @param options [Hash] additional options (required, placeholder, collection, etc.)
  # @return [Hash] formatted field
  def field_format(name:, type:, label:, **options)
    {
      name: name,
      type: type,
      label: label,
      **options
    }
  end

  # Helper to build a form panel
  # @param title [String] panel title
  # @param fields [Array<Hash>] panel fields
  # @param description [String, nil] panel description
  # @param icon [String, nil] panel icon
  # @return [Hash] formatted panel
  def panel_format(title:, fields:, description: nil, icon: nil)
    panel = {
      title: title,
      fields: fields
    }
    panel[:description] = description if description
    panel[:icon] = icon if icon
    panel
  end

  # Default breadcrumbs for forms
  # @return [Array<Hash>] empty breadcrumbs
  def default_breadcrumbs
    []
  end

  # Extract resource name from class name
  # @return [String] downcased resource name
  def resource_name
    self.class.name.split("::").last.gsub(/Page$/, "").downcase
  end
end
